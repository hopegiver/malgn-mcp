{
  "slug": "openai",
  "title": "OpenAI 통합",
  "category": "integration",
  "content": "# OpenAI 통합\n\n[← 목차로 돌아가기](README.md)\n\n---\n\n## 개요\n\n맑은프레임워크의 OpenAI 클래스는 OpenAI API(ChatGPT)를 쉽게 통합하여 AI 기능을 웹 애플리케이션에 추가할 수 있게 합니다.\n\n### 주요 특징\n\n- **JSON 문자열 기반 API**: 클라이언트에서 전체 대화 내역 전달\n- **자동 히스토리 관리**: 서버 메모리 기반 대화 관리\n- **스트림 지원**: 실시간 응답 출력\n- **포맷 검증**: messages 배열 자동 검증\n- **유연한 구조**: REST API와 세션 기반 모두 지원\n\n---\n\n## 기본 설정\n\n### OpenAI 객체 생성\n\n```jsp\n<%@ page contentType=\"text/html; charset=utf-8\" %><%@ include file=\"/init.jsp\" %><%\n\nOpenAI ai = new OpenAI();\n\n// API 키 설정 (필수)\nai.apiKey(\"sk-your-api-key-here\");\n\n// 모델 선택 (기본값: gpt-4o-mini)\nai.modelName(\"gpt-4o-mini\");\n\n// 또는 다른 모델\nai.modelName(\"gpt-4\");\nai.modelName(\"gpt-3.5-turbo\");\n\n%>\n```\n\n### 환경설정 파일 사용\n\n**config.xml**:\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<config>\n    <openaiApiKey>sk-your-api-key-here</openaiApiKey>\n</config>\n```\n\n**사용:**\n```jsp\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\n```\n\n---\n\n## 클라이언트 제어 방식\n\n클라이언트에서 전체 messages 배열을 JSON 문자열로 전달하는 현대적인 방식입니다. REST API에 적합합니다.\n\n### 1. 기본 사용법\n\n```jsp\n<%@ page contentType=\"application/json; charset=utf-8\" %><%@ include file=\"/init.jsp\" %><%\n\n// 클라이언트에서 messages JSON 받기\nString messagesJson = m.rs(\"messages\");\n\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\nai.modelName(\"gpt-4o-mini\");\n\n// AI 호출\nString response = ai.chat(messagesJson);\n\n// 에러 체크\nif(ai.errMsg != null) {\n    j.error(ai.errMsg);\n} else {\n    j.success(response);\n}\n\n%>\n```\n\n### 2. 클라이언트 예제 (JavaScript)\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>AI Chat</title>\n</head>\n<body>\n    <div id=\"chat\"></div>\n    <input type=\"text\" id=\"message\" placeholder=\"메시지를 입력하세요\">\n    <button onclick=\"sendMessage()\">전송</button>\n\n    <script>\n    let messages = [];\n\n    async function sendMessage() {\n        const userMessage = document.getElementById('message').value;\n\n        // 사용자 메시지 추가\n        messages.push({\n            role: \"user\",\n            content: userMessage\n        });\n\n        // 서버로 전송\n        const response = await fetch('/api/chat.jsp', {\n            method: 'POST',\n            headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n            body: 'messages=' + encodeURIComponent(JSON.stringify(messages))\n        });\n\n        const result = await response.json();\n\n        if(result.success) {\n            // AI 응답 추가\n            messages.push({\n                role: \"assistant\",\n                content: result.data\n            });\n\n            // 화면에 표시\n            displayMessage('user', userMessage);\n            displayMessage('assistant', result.data);\n        }\n\n        document.getElementById('message').value = '';\n    }\n    </script>\n</body>\n</html>\n```\n\n### 3. 시스템 프롬프트 포함\n\n```jsp\n<%@ page contentType=\"application/json; charset=utf-8\" %><%@ include file=\"/init.jsp\" %><%\n\nString messagesJson = m.rs(\"messages\");\n\n// messages에 system 메시지가 없으면 추가\nJSONArray messages = new JSONArray(messagesJson);\nif(messages.length() == 0 || !messages.getJSONObject(0).getString(\"role\").equals(\"system\")) {\n    JSONArray newMessages = new JSONArray();\n    newMessages.put(new JSONObject()\n        .put(\"role\", \"system\")\n        .put(\"content\", \"당신은 친절한 AI 도우미입니다.\")\n    );\n    for(int i = 0; i < messages.length(); i++) {\n        newMessages.put(messages.getJSONObject(i));\n    }\n    messagesJson = newMessages.toString();\n}\n\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\nString response = ai.chat(messagesJson);\n\nj.success(response);\n\n%>\n```\n\n---\n\n## 서버 자동 관리 방식\n\n세션에 대화 히스토리를 JSON 문자열로 저장하고 관리하는 간편한 방식입니다.\n\n### 1. 세션 기반 챗봇 (권장)\n\n```jsp\n<%@ page contentType=\"application/json; charset=utf-8\" %><%@ include file=\"/init.jsp\" %><%\n\n// OpenAI 객체 생성 (매번 새로 생성)\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\nai.modelName(\"gpt-4o-mini\");\n\n// 세션에서 히스토리 로드\nString historyJson = (String)session.getAttribute(\"chatHistory\");\nif(historyJson != null) {\n    ai.setHistory(historyJson);\n}\n\n// 사용자 메시지\nString message = m.rs(\"message\");\n\n// 자동으로 history에 추가되고 AI 호출\nString response = ai.chatMemory(message);\n\n// 세션에 히스토리 저장\nsession.setAttribute(\"chatHistory\", ai.getHistory());\n\nif(ai.errMsg != null) {\n    j.error(ai.errMsg);\n} else {\n    j.success(response);\n}\n\n%>\n```\n\n### 2. 시스템 프롬프트와 함께 사용\n\n```jsp\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\nai.modelName(\"gpt-4o-mini\");\n\n// 세션에서 히스토리 로드\nString historyJson = (String)session.getAttribute(\"chatHistory\");\nif(historyJson != null) {\n    ai.setHistory(historyJson);\n} else {\n    // 첫 대화일 경우 시스템 메시지 설정\n    ai.system(\"당신은 맑은프레임워크 전문가입니다. JSP와 Java에 대해 답변하세요.\");\n}\n\nString message = m.rs(\"message\");\nString response = ai.chatMemory(message);\n\nsession.setAttribute(\"chatHistory\", ai.getHistory());\n```\n\n### 3. 대화 히스토리 초기화\n\n```jsp\n// 세션에서 히스토리 제거\nsession.removeAttribute(\"chatHistory\");\n\nj.success(\"대화가 초기화되었습니다\");\n```\n\n---\n\n## 스트림 방식\n\n실시간으로 AI 응답을 받아 출력하는 방식입니다. 긴 응답을 받을 때 유용합니다.\n\n### 1. 기본 스트림\n\n```jsp\n<%@ page contentType=\"text/html; charset=utf-8\" %><%@ include file=\"/init.jsp\" %><%\n\nString messagesJson = m.rs(\"messages\");\n\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\n\n// 실시간으로 out에 출력하면서 fullResponse에도 저장\nString fullResponse = ai.streamChat(messagesJson, out);\n\n%>\n```\n\n### 2. 서버 자동 관리 + 스트림\n\n```jsp\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\n\n// 세션에서 히스토리 로드\nString historyJson = (String)session.getAttribute(\"chatHistory\");\nif(historyJson != null) {\n    ai.setHistory(historyJson);\n}\n\nString message = m.rs(\"message\");\n\n// 실시간으로 출력하면서 history에도 자동 저장\nString response = ai.streamMemory(message, out);\n\nsession.setAttribute(\"chatHistory\", ai.getHistory());\n```\n\n### 3. SSE (Server-Sent Events) 방식\n\n```jsp\n<%@ page contentType=\"text/event-stream; charset=utf-8\" %><%\n    response.setHeader(\"Cache-Control\", \"no-cache\");\n    response.setHeader(\"Connection\", \"keep-alive\");\n%><%@ include file=\"/init.jsp\" %><%\n\nString messagesJson = m.rs(\"messages\");\n\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\n\n// 커스텀 Writer로 SSE 포맷 출력\nWriter sseWriter = new Writer() {\n    public void write(char[] cbuf, int off, int len) throws IOException {\n        String chunk = new String(cbuf, off, len);\n        out.write(\"data: \" + chunk + \"\\n\\n\");\n        out.flush();\n    }\n    public void flush() throws IOException { out.flush(); }\n    public void close() throws IOException {}\n};\n\nString fullResponse = ai.streamChat(messagesJson, sseWriter);\n\nout.write(\"data: [DONE]\\n\\n\");\nout.flush();\n\n%>\n```\n\n---\n\n## 히스토리 관리\n\n대화 히스토리를 DB에 저장하고 불러오는 방법입니다.\n\n### 1. DB에 히스토리 저장\n\n```jsp\nOpenAI ai = new OpenAI();\nai.apiKey(Config.get(\"openaiApiKey\"));\n\n// DB에서 히스토리 로드\nChatHistoryDao chatHistory = new ChatHistoryDao();\nDataSet info = chatHistory.find(\"user_id = ?\", new Object[]{userId});\nif(info.next()) {\n    String historyJson = info.s(\"history\");\n    ai.setHistory(historyJson);\n}\n\n// 메시지 추가 및 AI 호출\nString response = ai.chatMemory(message);\n\n// DB에 히스토리 저장\nString updatedHistory = ai.getHistory();\nif(info.getRow() > 0) {\n    chatHistory.item(\"history\", updatedHistory);\n    chatHistory.update(\"user_id = ?\", new Object[]{userId});\n} else {\n    chatHistory.item(\"user_id\", userId);\n    chatHistory.item(\"history\", updatedHistory);\n    chatHistory.item(\"reg_date\", m.time());\n    chatHistory.insert();\n}\n```\n\n---\n\n## 고급 설정\n\n### 1. Temperature 조절\n\nTemperature는 응답의 무작위성을 제어합니다 (0.0 ~ 2.0):\n\n```jsp\n// 낮은 temperature (0.0 ~ 0.3): 일관되고 예측 가능한 응답\nai.temperature(0.2);\n\n// 중간 temperature (0.7): 균형잡힌 응답 (기본값)\nai.temperature(0.7);\n\n// 높은 temperature (1.0 ~ 2.0): 창의적이고 다양한 응답\nai.temperature(1.5);\n```\n\n### 2. 디버그 모드\n\n```jsp\nai.setDebug(out);  // HTTP 요청/응답을 out으로 출력\nai.setDebug();     // 또는 로그 파일로 출력\n```\n\n### 3. 시스템 메시지 설정\n\n```jsp\n// 시스템 메시지 설정 (이미 있으면 교체, 없으면 추가)\nai.system(\"당신은 친절한 AI 도우미입니다.\");\n```\n\n### 4. 최대 토큰 수 설정\n\n```jsp\n// 짧은 응답 (비용 절약)\nai.maxToken(100);\n\n// 긴 응답\nai.maxToken(2000);\n\n// 매우 긴 응답 (최대 4096)\nai.maxToken(4096);\n```\n\n### 5. 모델별 특징\n\n```jsp\n// gpt-3.5-turbo: 빠르고 저렴, 일반 작업에 적합\nai.modelName(\"gpt-3.5-turbo\");\n\n// gpt-4o-mini: 균형잡힌 성능, 대부분의 작업에 권장 (기본값)\nai.modelName(\"gpt-4o-mini\");\n\n// gpt-4: 가장 강력, 복잡한 추론 작업에 적합 (비쌈)\nai.modelName(\"gpt-4\");\n\n// gpt-4-turbo: gpt-4보다 빠르고 저렴\nai.modelName(\"gpt-4-turbo\");\n```\n\n---\n\n## 실제 활용 예제\n\n### 1. 문서 요약 API\n\n시스템 메시지를 사용하여 전문 요약가 역할을 설정하고 temperature를 낮게 설정하여 일관된 요약을 생성합니다.\n\n### 2. 감정 분석\n\npositive, negative, neutral로 분류하는 감정 분석 API입니다.\n\n### 3. JSON 데이터 생성\n\nAI를 활용하여 구조화된 JSON 데이터(퀴즈 문제 등)를 생성합니다.\n\n### 4. 번역 서비스\n\n시스템 메시지로 전문 번역가 역할을 설정하여 번역 서비스를 구현합니다.\n\n### 5. 코드 리뷰\n\nAI를 활용한 코드 리뷰 서비스입니다.\n\n### 6. 콘텐츠 생성기\n\n블로그 글 등의 콘텐츠를 AI로 생성합니다.\n\n---\n\n## 에러 처리\n\n### 1. 기본 에러 처리\n\n```jsp\nString response = ai.chat(messagesJson);\n\nif(ai.errMsg != null) {\n    m.p(\"Error: \" + ai.errMsg);\n    Malgn.errorLog(\"OpenAI API 에러: \" + ai.errMsg);\n} else if(response.isEmpty()) {\n    m.p(\"빈 응답이 반환되었습니다\");\n} else {\n    m.p(response);\n}\n```\n\n### 2. 검증 에러 처리\n\n메시지 형식, role 필드 등의 검증 에러를 처리합니다.\n\n### 3. Try-Catch 패턴\n\n```jsp\ntry {\n    OpenAI ai = new OpenAI();\n    ai.apiKey(Config.get(\"openaiApiKey\"));\n    String response = ai.chat(messagesJson);\n\n    if(ai.errMsg != null) {\n        throw new Exception(ai.errMsg);\n    }\n    j.success(response);\n} catch(Exception e) {\n    Malgn.errorLog(\"OpenAI API 에러\", e);\n    j.error(\"AI 서비스 오류: \" + e.getMessage());\n}\n```\n\n---\n\n## 비용 최적화 팁\n\n1. **적절한 모델 선택**: gpt-3.5-turbo(저렴) / gpt-4o-mini(권장) / gpt-4(비쌈)\n2. **프롬프트 최적화**: 간결한 프롬프트 사용\n3. **응답 길이 제한**: maxToken 설정\n4. **캐싱 활용**: 자주 묻는 질문은 캐시 사용\n\n---\n\n## 주의사항\n\n1. **API 키 보안**: Config.get()으로 환경설정 파일에서 로드\n2. **비용 관리**: 모델별 가격 차이, 토큰 수에 따른 과금\n3. **응답 시간**: 수 초가 걸릴 수 있으므로 스트림 방식 권장\n4. **콘텐츠 검증**: 생성된 콘텐츠 검토 필요\n5. **개인정보 보호**: 민감한 정보 제거 후 전송\n\n---\n\n## 관련 문서\n\n- [HTTP 클라이언트](http-client.md) - OpenAI가 내부적으로 사용\n- [JSON 처리](json.md) - AI 응답 파싱\n- [환경설정 및 캐시](configuration.md) - API 키 관리 및 응답 캐싱\n\n---\n\n[← 목차로 돌아가기](README.md)",
  "sections": [
    { "heading": "개요", "content": "OpenAI 클래스를 통한 ChatGPT API 통합으로 JSON 문자열 기반 API, 자동 히스토리 관리, 스트림 지원, 포맷 검증 기능을 제공합니다." },
    { "heading": "기본 설정", "content": "OpenAI 객체 생성, API 키 설정, 모델 선택(gpt-4o-mini 기본), config.xml 환경설정 방법입니다." },
    { "heading": "클라이언트 제어 방식", "content": "클라이언트에서 전체 messages 배열을 JSON 문자열로 전달하는 REST API 방식입니다." },
    { "heading": "서버 자동 관리 방식", "content": "세션에 대화 히스토리를 저장하고 chatMemory()로 자동 관리하는 간편한 방식입니다." },
    { "heading": "스트림 방식", "content": "streamChat()과 streamMemory()를 사용한 실시간 응답 출력과 SSE 방식입니다." },
    { "heading": "히스토리 관리", "content": "대화 히스토리를 DB에 저장하고 불러오는 방법과 히스토리 초기화 방법입니다." },
    { "heading": "고급 설정", "content": "Temperature 조절, 디버그 모드, 시스템 메시지 설정, 최대 토큰 수, 모델별 특징입니다." },
    { "heading": "실제 활용 예제", "content": "문서 요약, 감정 분석, JSON 데이터 생성, 번역 서비스, 코드 리뷰, 콘텐츠 생성기 예제입니다." },
    { "heading": "에러 처리", "content": "기본 에러 처리, 검증 에러, Try-Catch 패턴을 사용한 에러 처리 방법입니다." },
    { "heading": "비용 최적화 팁", "content": "적절한 모델 선택, 프롬프트 최적화, 응답 길이 제한, 캐싱 활용 등의 비용 절약 방법입니다." },
    { "heading": "주의사항", "content": "API 키 보안, 비용 관리, 응답 시간, 콘텐츠 검증, 개인정보 보호 등의 주의사항입니다." }
  ],
  "related_docs": ["http-client", "restapi", "restapi-jwt"],
  "related_classes": ["Malgn", "Json", "DataSet"]
}
