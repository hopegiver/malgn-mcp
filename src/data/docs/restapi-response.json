{
  "slug": "restapi-response",
  "title": "REST API - 응답 표준",
  "category": "web",
  "content": "# REST API - 응답 표준\n\n일관된 JSON 응답 형식을 사용하면 클라이언트에서 처리하기 쉽습니다.\n\n---\n\n## 응답 방식\n\n### 1. 표준 출력 방식 (권장)\n\n`j.success()` / `j.error()` 메소드를 사용하여 일관된 응답 형식을 제공합니다.\n\n```jsp\n// 성공 응답\nj.success(\"조회되었습니다.\", data);\n\n// 에러 응답\nj.error(\"NOT_FOUND\", \"사용자를 찾을 수 없습니다.\");\n```\n\n**장점:**\n- 일관된 응답 형식 (`success`, `message`, `data`/`details` 필드)\n- 클라이언트에서 처리하기 쉬움\n- 에러 코드 표준화\n\n**권장 사용:**\n- REST API 개발 시 기본적으로 사용\n- 표준화된 에러/성공 응답이 필요한 경우\n\n---\n\n### 2. 커스텀 출력 방식\n\n`j.put()` + `j.print()` 메소드로 자유로운 형식의 응답을 생성합니다.\n\n```jsp\n// 커스텀 응답\nj.put(\"users\", list);\nj.put(\"total\", total);\nj.put(\"page\", page);\nj.print();\n```\n\n**장점:**\n- 자유로운 응답 구조\n- 복잡한 페이징 응답 등에 유용\n- 레거시 시스템 호환\n\n**사용 예시:**\n- 복잡한 페이징 응답 (pagination, meta 구조)\n- 커서 기반 무한 스크롤\n- 특수한 응답 형식이 필요한 경우\n\n---\n\n## 에러 응답 표준\n\n### 1. 기본 에러 응답\n\n**간단한 에러 메시지:**\n```jsp\napi.get(\"/:id\", () -> {\n    int id = api.paramInt(\"id\");\n\n    UserDao user = new UserDao();\n    DataSet info = user.get(id);\n\n    if(info.next()) {\n        j.success(info);\n    } else {\n        // 에러 응답\n        j.error(\"사용자를 찾을 수 없습니다.\");\n    }\n});\n```\n\n**응답:**\n```json\n{\n  \"success\": false,\n  \"error\": \"ERROR\",\n  \"message\": \"사용자를 찾을 수 없습니다.\"\n}\n```\n\n---\n\n### 2. 에러 코드 포함\n\n**에러 코드와 메시지:**\n```jsp\napi.get(\"/:id\", () -> {\n    int id = api.paramInt(\"id\");\n\n    UserDao user = new UserDao();\n    DataSet info = user.get(id);\n\n    if(info.next()) {\n        j.success(info);\n    } else {\n        j.error(\"NOT_FOUND\", \"사용자를 찾을 수 없습니다.\");\n    }\n});\n```\n\n**응답:**\n```json\n{\n  \"success\": false,\n  \"error\": \"NOT_FOUND\",\n  \"message\": \"사용자를 찾을 수 없습니다.\"\n}\n```\n\n---\n\n### 3. 상세 정보 포함\n\n#### 방법 1: put()으로 details 설정 (간편함)\n\n```jsp\napi.post(\"/\", () -> {\n    String email = f.get(\"email\");\n\n    // 유효성 검사\n    if(\"\".equals(email)) {\n        // put()으로 details 데이터 설정\n        j.put(\"field\", \"email\");\n        j.put(\"reason\", \"required\");\n\n        // error() 호출 시 자동으로 details에 포함됨\n        j.error(\"VALIDATION_ERROR\", \"이메일은 필수입니다.\");\n        return;\n    }\n\n    // 이메일 형식 체크\n    if(!email.contains(\"@\")) {\n        j.put(\"field\", \"email\");\n        j.put(\"value\", email);\n        j.put(\"reason\", \"invalid_format\");\n\n        j.error(\"VALIDATION_ERROR\", \"이메일 형식이 올바르지 않습니다.\");\n        return;\n    }\n\n    // 정상 처리\n    UserDao user = new UserDao();\n    user.item(\"email\", email);\n\n    if(user.insert()) {\n        j.success(\"등록되었습니다.\", user.id);\n    } else {\n        j.error(\"DATABASE_ERROR\", user.getErrMsg());\n    }\n});\n```\n\n#### 방법 2: Map으로 details 직접 전달\n\n```jsp\napi.post(\"/\", () -> {\n    String email = f.get(\"email\");\n\n    if(\"\".equals(email)) {\n        Map<String, Object> details = new HashMap<>();\n        details.put(\"field\", \"email\");\n        details.put(\"reason\", \"required\");\n\n        j.error(\"VALIDATION_ERROR\", \"이메일은 필수입니다.\", details);\n        return;\n    }\n\n    // ...\n});\n```\n\n**응답:**\n```json\n{\n  \"success\": false,\n  \"error\": \"VALIDATION_ERROR\",\n  \"message\": \"이메일은 필수입니다.\",\n  \"details\": {\n    \"field\": \"email\",\n    \"reason\": \"required\"\n  }\n}\n```\n\n---\n\n### 4. HTTP 상태 코드와 함께\n\n```jsp\napi.post(\"/\", () -> {\n    String email = f.get(\"email\");\n\n    if(\"\".equals(email)) {\n        response.setStatus(400);  // Bad Request\n        j.error(\"VALIDATION_ERROR\", \"이메일은 필수입니다.\");\n        return;\n    }\n\n    UserDao user = new UserDao();\n    user.item(\"email\", email);\n\n    if(user.insert()) {\n        response.setStatus(201);  // Created\n        j.success(\"등록되었습니다.\", user.id);\n    } else {\n        response.setStatus(500);  // Internal Server Error\n        j.error(\"DATABASE_ERROR\", user.getErrMsg());\n    }\n});\n```\n\n---\n\n### 5. 주요 에러 코드 예시\n\n| HTTP 상태 | 에러 코드 | 설명 | 사용 예시 |\n|-----------|----------|------|----------|\n| 400 | `VALIDATION_ERROR` | 유효성 검사 실패 | `j.error(\"VALIDATION_ERROR\", \"이메일은 필수입니다.\")` |\n| 401 | `UNAUTHORIZED` | 인증 실패 | `j.error(\"UNAUTHORIZED\", \"로그인이 필요합니다.\")` |\n| 403 | `FORBIDDEN` | 권한 없음 | `j.error(\"FORBIDDEN\", \"관리자만 접근할 수 있습니다.\")` |\n| 404 | `NOT_FOUND` | 리소스 없음 | `j.error(\"NOT_FOUND\", \"사용자를 찾을 수 없습니다.\")` |\n| 409 | `CONFLICT` | 중복 (이메일 등) | `j.error(\"CONFLICT\", \"이미 등록된 이메일입니다.\")` |\n| 500 | `DATABASE_ERROR` | 데이터베이스 오류 | `j.error(\"DATABASE_ERROR\", user.getErrMsg())` |\n| 500 | `SERVER_ERROR` | 서버 오류 | `j.error(\"SERVER_ERROR\", \"서버 오류가 발생했습니다.\")` |\n\n---\n\n## 성공 응답 표준\n\n### 1. 기본 성공 응답\n\n```jsp\nj.success();\n```\n\n**응답:**\n```json\n{\n  \"success\": true,\n  \"message\": \"success\"\n}\n```\n\n---\n\n### 2. 메시지 포함\n\n```jsp\nj.success(\"등록되었습니다.\");\n```\n\n**응답:**\n```json\n{\n  \"success\": true,\n  \"message\": \"등록되었습니다.\"\n}\n```\n\n---\n\n### 3. 메시지와 데이터\n\n```jsp\nUserDao user = new UserDao();\nDataSet list = user.find();\nj.success(\"조회되었습니다.\", list);\n```\n\n**응답:**\n```json\n{\n  \"success\": true,\n  \"message\": \"조회되었습니다.\",\n  \"data\": [\n    {\"id\": 1, \"name\": \"홍길동\", \"email\": \"hong@example.com\"},\n    {\"id\": 2, \"name\": \"김철수\", \"email\": \"kim@example.com\"}\n  ]\n}\n```\n\n---\n\n### 4. put()으로 데이터 설정 (자동 포함)\n\n```jsp\napi.post(\"/\", () -> {\n    UserDao user = new UserDao();\n    user.item(\"name\", f.get(\"name\"));\n    user.item(\"email\", f.get(\"email\"));\n\n    if(user.insert()) {\n        j.put(\"user_id\", user.id);\n        j.put(\"created_at\", System.currentTimeMillis());\n        j.success(\"등록되었습니다.\");  // put()으로 설정한 데이터가 자동 포함\n    } else {\n        j.error(\"DATABASE_ERROR\", user.getErrMsg());\n    }\n});\n```\n\n**응답:**\n```json\n{\n  \"success\": true,\n  \"message\": \"등록되었습니다.\",\n  \"data\": {\n    \"user_id\": 123,\n    \"created_at\": 1704067200000\n  }\n}\n```\n\n---\n\n## 페이징 응답 표준\n\n### 1. 기본 페이징 응답\n\n```jsp\napi.get(\"/\", () -> {\n    int page = m.ri(\"page\", 1);\n    int size = m.ri(\"size\", 20);\n\n    UserDao user = new UserDao();\n    DataSet list = user.findWithPaging(page, size);\n    int total = user.getTotal();\n\n    // 페이징 응답\n    j.put(\"data\", list);  // 실제 데이터\n    j.put(\"pagination\", new JSONObject()\n        .put(\"page\", page)\n        .put(\"size\", size)\n        .put(\"total\", total)\n        .put(\"totalPages\", (int) Math.ceil((double) total / size))\n    );\n    j.print();\n});\n```\n\n---\n\n### 2. Json 클래스 활용\n\n```jsp\napi.get(\"/\", () -> {\n    int page = m.ri(\"page\", 1);\n    int size = m.ri(\"size\", 20);\n    String keyword = m.rs(\"keyword\");\n\n    UserDao user = new UserDao();\n    DataSet list = user.search(keyword, page, size);\n    int total = user.getTotal();\n\n    j.put(\"users\", list);\n    j.put(\"total\", total);\n    j.put(\"page\", page);\n    j.put(\"size\", size);\n    j.put(\"totalPages\", (int) Math.ceil((double) total / size));\n    j.put(\"hasNext\", page < Math.ceil((double) total / size));\n    j.put(\"hasPrev\", page > 1);\n    j.print();\n});\n```\n\n---\n\n### 3. 커서 기반 페이징 (무한 스크롤)\n\n```jsp\napi.get(\"/\", () -> {\n    int cursor = m.ri(\"cursor\", 0);  // 마지막 ID\n    int size = m.ri(\"size\", 20);\n\n    UserDao user = new UserDao();\n    DataSet list = user.findByCursor(cursor, size);\n\n    int nextCursor = 0;\n    if(list.last()) {\n        nextCursor = list.i(\"id\");\n    }\n\n    j.put(\"data\", list);\n    j.put(\"cursor\", nextCursor);\n    j.put(\"hasMore\", list.size() == size);  // size만큼 가져왔으면 더 있을 가능성\n    j.print();\n});\n```\n\n---\n\n### 4. 메타데이터 포함 응답\n\n```jsp\nj.put(\"data\", list);\nj.put(\"meta\", new JSONObject()\n    .put(\"total\", total)\n    .put(\"page\", page)\n    .put(\"size\", size)\n    .put(\"totalPages\", totalPages)\n    .put(\"timestamp\", System.currentTimeMillis())\n    .put(\"version\", \"v1\")\n);\nj.print();\n```\n\n---\n\n## 관련 문서\n\n- [REST API 개발](restapi.md) - REST API 기본 가이드\n- [JWT 인증](restapi-jwt.md) - JWT 인증 가이드\n- [CORS 설정](restapi-cors.md) - CORS 설정 가이드\n- [JSON 처리](json.md) - Json 클래스 상세 가이드\n\n---\n\n[← 목차로 돌아가기](README.md)",
  "sections": [
    { "heading": "응답 방식", "content": "표준 출력 방식(j.success()/j.error())과 커스텀 출력 방식(j.put()+j.print())의 두 가지 응답 방식을 제공합니다." },
    { "heading": "에러 응답 표준", "content": "기본 에러 응답, 에러 코드 포함, 상세 정보 포함, HTTP 상태 코드, 주요 에러 코드 예시를 다룹니다." },
    { "heading": "성공 응답 표준", "content": "기본 성공 응답, 메시지 포함, 메시지와 데이터, put()으로 데이터 설정 방법을 설명합니다." },
    { "heading": "페이징 응답 표준", "content": "기본 페이징 응답, Json 클래스 활용, 커서 기반 페이징(무한 스크롤), 메타데이터 포함 응답을 제공합니다." },
    { "heading": "관련 문서", "content": "REST API 기본 가이드, JWT 인증, CORS 설정, JSON 처리 등의 관련 문서 목록입니다." }
  ],
  "related_docs": ["restapi", "restapi-jwt", "restapi-cors"],
  "related_classes": ["RestAPI", "Json", "Malgn", "Form", "DataSet"]
}
